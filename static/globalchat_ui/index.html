<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Global Chat | CodeChicks</title>
    <meta name="description" content="CodeChicks Global Chat - Connect with the community">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="/static/globalchat_ui/style.css?v=2">
    <link rel="stylesheet" href="/static/css/timer-overlay.css?v=2">
</head>

<body>
    <!-- Auth check - redirects if no token -->
    <script src="/static/js/auth.js"></script>

    <div class="chat-container">
        <!-- Sidebar -->
        <aside class="chat-sidebar glass-panel">
            <div class="sidebar-header">
                <a href="/dashboard" class="back-btn">‚Üê Back</a>
                <h2 class="sidebar-title">Global Chat</h2>
            </div>

            <div class="sidebar-nav">
                <ul class="nav-links">
                    <li><a href="/dashboard"><i class="fas fa-chart-pie"></i> Dashboard</a></li>
                    <li class="active"><a href="/chat"><i class="fas fa-comments"></i> Chat</a></li>
                    <li><a href="/clock"><i class="fas fa-clock"></i> Timer</a></li>
                    <li><a href="/settings"><i class="fas fa-cog"></i> Settings</a></li>
                </ul>
                <div class="admin-link" id="adminLink" style="display: none;">
                    <a href="/admin" class="admin-btn">
                        <i class="fas fa-crown"></i> Admin Panel
                    </a>
                </div>
            </div>

            <div class="online-users">
                <div class="section-header">
                    <span class="section-title">Online Now</span>
                    <span class="online-count" id="onlineCount">--</span>
                </div>
                <div class="users-list" id="usersList">
                    <!-- Users will be populated here -->
                    <div class="loading-users">
                        <i class="fas fa-spinner fa-spin"></i>
                    </div>
                </div>
            </div>

            <div class="sidebar-footer">
                <button class="logout-btn glass-btn" onclick="logout()">
                    <i class="fas fa-sign-out-alt"></i> Logout
                </button>
            </div>
        </aside>

        <!-- Main Chat Area -->
        <main class="chat-main">
            <!-- Chat Header -->
            <header class="chat-header glass-panel">
                <div class="chat-info">
                    <h1 class="chat-title">Global Chat</h1>
                    <span class="chat-subtitle" id="statusText">
                        <span class="connection-dot disconnected" id="connectionDot"></span>
                        <span id="connectionStatus">Connecting...</span>
                    </span>
                </div>
                <div class="chat-actions">
                    <button class="action-btn glass-btn" onclick="reconnectWebSocket()" title="Reconnect">
                        <i class="fas fa-sync-alt"></i>
                    </button>
                </div>
            </header>

            <!-- Messages Area -->
            <div class="messages-area" id="messages-area">
                <div class="loading-indicator" id="loadingMessages">
                    <i class="fas fa-spinner fa-spin"></i> Connecting to chat...
                </div>
            </div>

            <!-- Reply Preview and Input Wrapper -->
            <div class="chat-input-wrapper">
                <!-- Reply Preview (Initially Hidden) -->
                <div class="message-reply-preview" id="replyPreview">
                    <div class="reply-info">
                        <span class="reply-to-user" id="replyToUser">Replying to...</span>
                        <span class="reply-to-text" id="replyToText">...</span>
                    </div>
                    <button class="cancel-reply-btn" onclick="cancelReply()">
                        <i class="fas fa-times"></i>
                    </button>
                </div>

                <!-- Message Input -->
                <div class="message-input-area glass-panel">
                    <form id="messageForm" onsubmit="sendMessage(event)">
                        <input type="text" class="message-input" id="message-input" placeholder="Type your message..."
                            autocomplete="off" required>
                        <button type="submit" class="send-btn" id="send-btn" title="Send">
                            <span>‚û§</span>
                        </button>
                    </form>
                </div>
            </div>
        </main>
    </div>

    <!-- Delete Confirmation Modal -->
    <div class="modal-overlay" id="deleteModal">
        <div class="modal-content">
            <h3 class="modal-title">Delete Message</h3>
            <p class="modal-text">Are you sure you want to delete this message? This action cannot be undone.</p>
            <div class="modal-actions">
                <button class="modal-btn cancel" onclick="cancelDelete()">Cancel</button>
                <button class="modal-btn confirm" onclick="confirmDelete()">Delete</button>
            </div>
        </div>
    </div>

    <style>
        /* WebSocket connection indicator */
        .connection-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 6px;
            transition: background-color 0.3s;
        }

        .connection-dot.connected {
            background-color: #43e97b;
            box-shadow: 0 0 6px #43e97b;
        }

        .connection-dot.disconnected {
            background-color: #ff6b6b;
            box-shadow: 0 0 6px #ff6b6b;
        }

        .connection-dot.connecting {
            background-color: #ffc107;
            box-shadow: 0 0 6px #ffc107;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        /* System message styling */
        .message.system {
            display: flex;
            justify-content: center;
            margin: 10px 0;
        }

        .message.system .message-content {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 8px 16px;
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.6);
            font-style: italic;
        }
    </style>

    <script src="/static/js/timer-overlay.js"></script>
    <script>
        // ============================================================
        // WEBSOCKET GLOBAL CHAT - REAL-TIME MESSAGING
        // ============================================================

        let currentUserEmail = null;
        let currentUserName = null;
        let websocket = null;
        let reconnectAttempts = 0;
        let maxReconnectAttempts = 5;
        let reconnectDelay = 1000;

        // State for active actions
        let messageToDeleteId = null;
        let activeEditId = null;
        let originalTextMap = {}; // Map to store text before edit

        // Reply State
        let activeReplyData = null; // { id, username, text }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', async () => {
            const user = await getCurrentUser();
            if (user) {
                currentUserEmail = user.email;
                currentUserName = user.display_name || user.username || user.email.split('@')[0];

                // Show admin link for admin users
                if (user.role === 'admin') {
                    document.getElementById('adminLink').style.display = 'block';
                }
            }

            // Initialize WebSocket connection
            connectWebSocket();

            // Load historical messages via HTTP
            await loadHistoricalMessages();

            // Update UI
            updateUsersList();
        });

        // ============================================================
        // POLLING-BASED CHAT (Vercel doesn't support WebSockets)
        // ============================================================

        let pollingInterval = null;
        const POLL_INTERVAL_MS = 3000; // Poll every 3 seconds
        let lastMessageId = null; // Track newest message to detect new ones

        function connectWebSocket() {
            // Vercel doesn't support WebSockets, use HTTP polling instead
            console.log('üîÑ Starting HTTP polling mode (WebSocket not supported on Vercel)');
            updateConnectionStatus('polling');

            // Hide loading indicator
            const loading = document.getElementById('loadingMessages');
            if (loading) loading.style.display = 'none';

            // Start polling for new messages
            startPolling();
        }

        function startPolling() {
            if (pollingInterval) {
                clearInterval(pollingInterval);
            }

            pollingInterval = setInterval(async () => {
                await pollForNewMessages();
            }, POLL_INTERVAL_MS);

            // Also poll immediately
            pollForNewMessages();
        }

        async function pollForNewMessages() {
            try {
                const response = await authFetch('/api/chat/messages?page_size=20');
                if (!response || !response.ok) return;

                const data = await response.json();
                const messages = data.messages;

                if (messages.length > 0) {
                    const newestId = messages[0].id; // Messages are sorted newest first

                    // If we have new messages since last poll
                    if (lastMessageId && newestId !== lastMessageId) {
                        // Find new messages (those we haven't seen)
                        for (let i = messages.length - 1; i >= 0; i--) {
                            const msg = messages[i];
                            if (!document.getElementById(`msg-${msg.id}`)) {
                                // This is a new message, add it
                                handleIncomingMessage({
                                    type: 'message',
                                    id: msg.id,
                                    username: msg.sender_name,
                                    sender_id: msg.sender_id,
                                    message: msg.content,
                                    timestamp: msg.timestamp,
                                    reply_to_id: msg.reply_to_id,
                                    reply_to_username: msg.reply_to_username,
                                    reply_to_content: msg.reply_to_content
                                });
                            }
                        }
                    }
                    lastMessageId = newestId;
                }
            } catch (error) {
                console.error('Polling error:', error);
            }
        }

        function reconnectWebSocket() {
            // For polling mode, just restart polling
            if (pollingInterval) {
                clearInterval(pollingInterval);
            }
            startPolling();
        }

        function updateConnectionStatus(status) {
            const dot = document.getElementById('connectionDot');
            const text = document.getElementById('connectionStatus');

            dot.className = 'connection-dot ' + status;

            switch (status) {
                case 'connected':
                    text.textContent = 'Connected';
                    break;
                case 'polling':
                    dot.className = 'connection-dot connected'; // Green dot
                    text.textContent = 'Connected (Polling)';
                    break;
                case 'disconnected':
                    text.textContent = 'Disconnected';
                    break;
                case 'connecting':
                    text.textContent = 'Connecting...';
                    break;
            }
        }

        // ============================================================
        // MESSAGE HANDLING
        // ============================================================

        function handleIncomingMessage(data) {
            const area = document.getElementById('messages-area');

            // Hide loading if still showing
            const loading = document.getElementById('loadingMessages');
            if (loading) loading.style.display = 'none';

            // Check if this is a system message or user message
            if (data.type === 'system') {
                // System notification (user joined/left)
                const messageHtml = `
                    <div class="message system">
                        <div class="message-content">
                            <i class="fas fa-info-circle"></i> ${escapeHtml(data.message)}
                        </div>
                    </div>
                `;
                area.insertAdjacentHTML('beforeend', messageHtml);
            } else if (data.type === 'message') {
                // User message
                const isSelf = (data.sender_id === currentUserEmail) || (data.username === currentUserName); // Fallback
                const displayName = data.username || 'Anonymous';
                const avatarLetter = displayName[0].toUpperCase();
                const avatarColor = getAvatarColor(displayName);
                const msgId = data.id || `temp-${Date.now()}`;

                // Quote HTML if replying
                let quoteHtml = '';
                if (data.reply_to_id) {
                    quoteHtml = `
                        <div class="message-quote" onclick="scrollToMessage('${data.reply_to_id}')">
                            <div class="quote-user">${escapeHtml(data.reply_to_username || 'User')}</div>
                            <div class="quote-text">${escapeHtml(data.reply_to_content || '...')}</div>
                        </div>
                    `;
                }

                let messageHtml;
                if (isSelf) {
                    messageHtml = `
                        <div class="message self" id="msg-${msgId}" data-id="${msgId}">
                            <div class="message-actions">
                                <button class="message-action-btn reply" onclick="replyToMessage('${msgId}', 'You', '${escapeHtml(data.message).replace(/'/g, "\\'")}')" title="Reply">
                                    <i class="fas fa-reply"></i>
                                </button>
                                <button class="message-action-btn" onclick="editMessage('${msgId}')" title="Edit">
                                    <i class="fas fa-pen"></i>
                                </button>
                                <button class="message-action-btn delete" onclick="openDeleteModal('${msgId}')" title="Delete">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </div>
                            <div class="message-content">
                                ${quoteHtml}
                                <div class="message-header">
                                    <span class="message-author">You</span>
                                    <span class="message-time">${formatTime(data.timestamp)}</span>
                                </div>
                                <p class="message-text">${escapeHtml(data.message)}</p>
                            </div>
                        </div>
                    `;
                } else {
                    messageHtml = `
                        <div class="message other" id="msg-${msgId}" data-id="${msgId}">
                            <div class="message-avatar" style="background: ${avatarColor};">${avatarLetter}</div>
                            <div class="message-content">
                                ${quoteHtml}
                                <div class="message-header">
                                    <span class="message-author">${escapeHtml(displayName)}</span>
                                    <span class="message-time">${formatTime(data.timestamp)}</span>
                                    <button class="message-action-btn reply" onclick="replyToMessage('${msgId}', '${escapeHtml(displayName).replace(/'/g, "\\'")}', '${escapeHtml(data.message).replace(/'/g, "\\'")}')" title="Reply" style="margin-left:auto; opacity:0.6;">
                                        <i class="fas fa-reply"></i>
                                    </button>
                                </div>
                                <p class="message-text">${escapeHtml(data.message)}</p>
                            </div>
                        </div>
                    `;
                }
                area.insertAdjacentHTML('beforeend', messageHtml);
            }

            // Scroll to bottom
            area.scrollTop = area.scrollHeight;
        }

        function handleMessageEdit(data) {
            const msgEl = document.getElementById(`msg-${data.id}`);
            if (msgEl) {
                // If this is active edit, cancel it first to restore DOM structure if needed
                if (activeEditId === data.id) {
                    activeEditId = null;
                }

                const contentDiv = msgEl.querySelector('.message-content');
                let header = msgEl.querySelector('.message-header')?.outerHTML;

                // Recover header if missing relative to edit mode
                if (!header && originalTextMap[data.id]) {
                    const temp = document.createElement('div');
                    temp.innerHTML = originalTextMap[data.id];
                    header = temp.querySelector('.message-header')?.outerHTML;
                }

                if (!header) {
                    header = `
                        <div class="message-header">
                            <span class="message-author">You</span>
                            <span class="message-time">${formatTime(new Date())}</span>
                        </div>`;
                }

                // Preserve quote if it exists
                let quoteHtml = '';
                const existingQuote = contentDiv.querySelector('.message-quote');
                if (existingQuote) {
                    quoteHtml = existingQuote.outerHTML;
                } else if (originalTextMap[data.id]) {
                    const temp = document.createElement('div');
                    temp.innerHTML = originalTextMap[data.id];
                    const oldQuote = temp.querySelector('.message-quote');
                    if (oldQuote) quoteHtml = oldQuote.outerHTML;
                }

                if (contentDiv) {
                    contentDiv.innerHTML = `
                        ${quoteHtml}
                        ${header}
                        <p class="message-text">${escapeHtml(data.message)} <small style="opacity:0.6; font-size:0.7em">(edited)</small></p>
                    `;
                    delete originalTextMap[data.id];
                }

                // Flash effect
                msgEl.style.transition = 'background-color 0.5s';
                msgEl.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
                setTimeout(() => { msgEl.style.backgroundColor = ''; }, 500);
            }
        }

        function handleMessageDelete(data) {
            const msgEl = document.getElementById(`msg-${data.id}`);
            if (msgEl) {
                msgEl.style.transition = 'all 0.3s ease';
                msgEl.style.opacity = '0';
                msgEl.style.transform = 'scale(0.9)';
                setTimeout(() => msgEl.remove(), 300);
            }
        }

        // ============================================================
        // ACTIONS (Reply / Edit / Delete)
        // ============================================================

        // --- REPLY ---
        function replyToMessage(id, username, text) {
            activeReplyData = { id, username, text };

            // Show preview
            document.getElementById('replyToUser').textContent = `Replying to ${username}`;
            document.getElementById('replyToText').textContent = text;
            document.getElementById('replyPreview').classList.add('active');

            // Focus input
            document.getElementById('message-input').focus();
        }

        function cancelReply() {
            activeReplyData = null;
            document.getElementById('replyPreview').classList.remove('active');
        }

        function scrollToMessage(id) {
            const el = document.getElementById(`msg-${id}`);
            if (el) {
                el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                // Flash
                el.style.transition = 'background-color 0.5s';
                el.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
                setTimeout(() => { el.style.backgroundColor = ''; }, 1000);
            }
        }

        // --- INLINE EDITING ---
        function editMessage(id) {
            // Prevent multiple edits at once
            if (activeEditId) {
                cancelEdit(activeEditId);
            }

            const msgEl = document.getElementById(`msg-${id}`);
            if (!msgEl) return;

            const textEl = msgEl.querySelector('.message-text');
            if (!textEl) return;

            // Save original text
            const currentText = textEl.textContent.replace('(edited)', '').trim();
            originalTextMap[id] = msgEl.querySelector('.message-content').innerHTML; // Save full HTML structure
            activeEditId = id;

            // Create Inline Editor HTML
            const editorHtml = `
                    <div class="message-header">
                        <span class="message-author">You</span>
                        <span class="message-time">Editing...</span>
                    </div>
                    <div class="inline-editor">
                        <textarea class="inline-edit-input" id="edit-input-${id}" rows="2">${currentText}</textarea>
                        <div class="edit-actions">
                            <button class="edit-btn cancel" onclick="cancelEdit('${id}')">Cancel</button>
                            <button class="edit-btn save" onclick="saveEdit('${id}')">Save</button>
                        </div>
                    </div>
            `;

            const contentDiv = msgEl.querySelector('.message-content');
            contentDiv.innerHTML = editorHtml;

            // Focus and put cursor at end
            const input = document.getElementById(`edit-input-${id}`);
            input.focus();
            input.setSelectionRange(input.value.length, input.value.length);

            // Handle Enter key to save (Shift+Enter for new line)
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    saveEdit(id);
                }
                if (e.key === 'Escape') {
                    cancelEdit(id);
                }
            });
        }

        function cancelEdit(id) {
            const msgEl = document.getElementById(`msg-${id}`);
            if (msgEl && originalTextMap[id]) {
                const contentDiv = msgEl.querySelector('.message-content');
                contentDiv.innerHTML = originalTextMap[id];
                delete originalTextMap[id];
                activeEditId = null;
            }
        }

        async function saveEdit(id) {
            const input = document.getElementById(`edit-input-${id}`);
            if (!input) return;

            const newText = input.value.trim();

            if (!newText) {
                alert("Message cannot be empty.");
                return;
            }

            try {
                const response = await authFetch(`/api/chat/messages/${id}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ content: newText })
                });

                if (response && response.ok) {
                    // Update UI
                    handleMessageEdit({ id: id, message: newText });
                } else {
                    alert('Failed to edit message.');
                    cancelEdit(id);
                }
            } catch (error) {
                console.error('Edit error:', error);
                alert('Failed to edit message.');
                cancelEdit(id);
            }
        }


        // --- DELETE MODAL ---
        function openDeleteModal(id) {
            messageToDeleteId = id;
            const modal = document.getElementById('deleteModal');
            modal.classList.add('active');
        }

        function cancelDelete() {
            messageToDeleteId = null;
            const modal = document.getElementById('deleteModal');
            modal.classList.remove('active');
        }

        async function confirmDelete() {
            if (!messageToDeleteId) return;

            try {
                const response = await authFetch(`/api/chat/messages/${messageToDeleteId}`, {
                    method: 'DELETE'
                });

                if (response && (response.ok || response.status === 204)) {
                    // Update UI
                    handleMessageDelete({ id: messageToDeleteId });
                } else {
                    alert('Failed to delete message.');
                }
            } catch (error) {
                console.error('Delete error:', error);
                alert('Failed to delete message.');
            }

            cancelDelete(); // Close modal
        }

        // Close modal on outside click
        document.getElementById('deleteModal').addEventListener('click', (e) => {
            if (e.target.id === 'deleteModal') {
                cancelDelete();
            }
        });


        // ============================================================
        // SEND MESSAGE VIA HTTP POST (Polling mode)
        // ============================================================

        async function sendMessage(event) {
            event.preventDefault();

            const input = document.getElementById('message-input');
            const btn = document.getElementById('send-btn');
            const content = input.value.trim();

            if (!content) return;

            btn.disabled = true;
            input.disabled = true;

            try {
                // Build message payload
                const payload = {
                    content: content,
                    room_id: 'global'
                };

                // Add reply data if replying to a message
                if (activeReplyData) {
                    payload.reply_to_id = activeReplyData.id;
                    payload.reply_to_username = activeReplyData.username;
                    payload.reply_to_content = activeReplyData.text.substring(0, 100); // Truncate
                }

                // Send message via HTTP POST
                const response = await authFetch('/api/chat/messages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });

                if (!response || !response.ok) {
                    throw new Error('Failed to send message');
                }

                const newMsg = await response.json();

                // Display the message immediately
                handleIncomingMessage({
                    type: 'message',
                    id: newMsg.id,
                    username: newMsg.sender_name,
                    sender_id: newMsg.sender_id,
                    message: newMsg.content,
                    timestamp: newMsg.timestamp,
                    reply_to_id: newMsg.reply_to_id,
                    reply_to_username: newMsg.reply_to_username,
                    reply_to_content: newMsg.reply_to_content
                });

                input.value = '';

                // Clear reply state
                if (activeReplyData) {
                    cancelReply();
                }

            } catch (error) {
                console.error('Send error:', error);
                alert('Failed to send message. Please try again.');
            } finally {
                btn.disabled = false;
                input.disabled = false;
                input.focus();
            }
        }

        // ============================================================
        // LOAD HISTORICAL MESSAGES (HTTP fallback)
        // ============================================================

        async function loadHistoricalMessages() {
            try {
                const response = await authFetch('/api/chat/messages?page_size=50');
                if (!response || !response.ok) return;

                const data = await response.json();
                const area = document.getElementById('messages-area');
                const loading = document.getElementById('loadingMessages');

                if (loading) loading.style.display = 'none';

                // Clear and rebuild messages (reverse to show oldest first)
                const messages = data.messages.reverse();

                if (messages.length === 0) {
                    area.innerHTML = '<div class="empty-state"><i class="fas fa-comment-slash"></i><p>No messages yet. Start the conversation!</p></div>';
                    return;
                }

                area.innerHTML = messages.map(msg => {
                    const isSelf = msg.sender_id === currentUserEmail;
                    const displayName = msg.sender_name || msg.sender_id.split('@')[0];
                    const avatarLetter = displayName[0].toUpperCase();
                    const avatarColor = getAvatarColor(msg.sender_id);
                    const msgId = msg.id;

                    // Quote HTML
                    let quoteHtml = '';
                    if (msg.reply_to_id) {
                        quoteHtml = `
                            <div class="message-quote" onclick="scrollToMessage('${msg.reply_to_id}')">
                                <div class="quote-user">${escapeHtml(msg.reply_to_username || 'User')}</div>
                                <div class="quote-text">${escapeHtml(msg.reply_to_content || '...')}</div>
                            </div>
                        `;
                    }

                    if (isSelf) {
                        return `
                        <div class="message self" id="msg-${msgId}" data-id="${msgId}">
                            <div class="message-actions">
                                <button class="message-action-btn reply" onclick="replyToMessage('${msgId}', 'You', '${escapeHtml(msg.content).replace(/'/g, "\\'")}')" title="Reply">
                                    <i class="fas fa-reply"></i>
                                </button>
                                <button class="message-action-btn" onclick="editMessage('${msgId}')" title="Edit">
                                    <i class="fas fa-pen"></i>
                                </button>
                                <button class="message-action-btn delete" onclick="openDeleteModal('${msgId}')" title="Delete">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </div>
                                <div class="message-content">
                                    ${quoteHtml}
                                    <div class="message-header">
                                        <span class="message-author">You</span>
                                        <span class="message-time">${formatTime(msg.timestamp)}</span>
                                    </div>
                                    <p class="message-text">${escapeHtml(msg.content)}</p>
                                </div>
                            </div>
                        `;
                    } else {
                        return `
                            <div class="message other" id="msg-${msgId}" data-id="${msgId}">
                                <div class="message-avatar" style="background: ${avatarColor};">${avatarLetter}</div>
                                <div class="message-content">
                                    ${quoteHtml}
                                    <div class="message-header">
                                        <span class="message-author">${escapeHtml(displayName)}</span>
                                        <span class="message-time">${formatTime(msg.timestamp)}</span>
                                        <button class="message-action-btn reply" onclick="replyToMessage('${msgId}', '${escapeHtml(displayName).replace(/'/g, "\\'")}', '${escapeHtml(msg.content).replace(/'/g, "\\'")}')" title="Reply" style="margin-left:auto; opacity:0.6;">
                                            <i class="fas fa-reply"></i>
                                        </button>
                                    </div>
                                    <p class="message-text">${escapeHtml(msg.content)}</p>
                                </div>
                            </div>
                        `;
                    }
                }).join('');

                // Scroll to bottom
                area.scrollTop = area.scrollHeight;

            } catch (error) {
                console.error('Failed to load historical messages:', error);
            }
        }

        function updateUsersList() {
            const usersList = document.getElementById('usersList');
            usersList.innerHTML = `
                <div class="user-item online">
                    <div class="user-avatar" style="background: #667eea;">${currentUserName ? currentUserName[0].toUpperCase() : 'U'}</div>
                    <span class="user-name">${currentUserName || 'You'} (You)</span>
                    <span class="status-dot"></span>
                </div>
            `;
        }

        // ============================================================
        // UTILITY FUNCTIONS
        // ============================================================

        function formatTime(timestamp) {
            const date = new Date(timestamp);
            const now = new Date();

            const timeOptions = {
                hour: '2-digit',
                minute: '2-digit',
                hour12: true,
                timeZone: 'Asia/Kolkata'
            };
            const dateOptions = {
                month: 'short',
                day: 'numeric',
                timeZone: 'Asia/Kolkata'
            };

            const dateFormatter = new Intl.DateTimeFormat('en-IN', {
                year: 'numeric', month: '2-digit', day: '2-digit',
                timeZone: 'Asia/Kolkata'
            });
            const isToday = dateFormatter.format(date) === dateFormatter.format(now);

            if (isToday) {
                return date.toLocaleTimeString('en-IN', timeOptions);
            }
            return date.toLocaleDateString('en-IN', dateOptions) +
                ' ' + date.toLocaleTimeString('en-IN', timeOptions);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function getAvatarColor(identifier) {
            const colors = ['#667eea', '#f5576c', '#43e97b', '#4facfe', '#ffc107', '#ff6b6b', '#48dbfb', '#ff9ff3'];
            let hash = 0;
            for (let i = 0; i < identifier.length; i++) {
                hash = identifier.charCodeAt(i) + ((hash << 5) - hash);
            }
            return colors[Math.abs(hash) % colors.length];
        }
    </script>
</body>

</html>